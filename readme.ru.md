## Пример реализации равномерного дерева квадратов.


#### TL;DR;

Здесь у меня нет стремления к вселенской оптимальности, скорости света или аскетизму в памяти.
Здесь можно найти небольшой MVP, скромный прототип, на котором я отработал только одну функцию дерева.
В этом прототипе проверяется работа дерева через аренду фигур + управление памятью и временем жизни фигур изнутри дерева.
Не могу сказать что я нахожу этот подход до конца правильным, но право на жизнь у такого подхода тоже имеется.
И я это право реализовал.

Реальный код выглядит несколько иначе, обладает иными характеристиками и находится в составе закрытой части моего [фреймворка](https://github.com/black-io).


#### Quad Tree

Про дерево квадратов (или Quad Tree) можно во всех деталях почитать на [Wiki](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D0%BD%D1%82%D0%BE%D0%B2).

Деревья квадратов используются для реализации разного рода пространственных индексов, чтобы быстрее и эффективнее находить объекты в некоторой окрестности.
Такие деревья позволяют быстрый поиск и обнаружение в 2D-пространствах и не подходят для эффективного поиска в 3D пространствах.


#### Что поддерживается

Этот код умеет:

- Позволяет "арендовать" занимаемую в пространстве площадь. Пока фигура арендуется, она доступна для выдачи в функциях поиска.
- Реализует стратегию индексирования в узлах. Квадранты умеют одновременно хранить как списки фигур, так и ссылки на элементы поддерева.
- Индексирует фигуру целиком. Фигура всегда индексируется тем квадрантом, в пространство которого максимально плотно вписывается.
- Позволяет поиск в окрестности разного вида.
- Позволяет перемещать арендуемые фигуры. При этом фигура повторно индексируется.
- Динамически определяет размеры области индексирования.

Каждая арендуемая фигура описывается своей собственной рамкой (AABR - Axis-Aligned Bounding Rect). Именно эта рамка фигурирует при индексации и поиске фигуры.
Интерфейс фигуры позволяет задать положение новой рамки. При этом запустится механизм повторной индексации или сброса всего дерева.

Само дерево индексов строится отложенно, когда после сброса всего дерева производится первый запрос поиска. Дерево при этом строится все целиком.

Для квадрантов характерно только одно состояние - состояние листа сразу после создания квадранта. В этом состоянии квадрант только накапливает фигуры,
пока не достигнет лимита разделения на поддерево. После разделения на поддерево квадрант уже не может вернуться в состояние листа.
При этом, любой квадрант всегда способен хранить таблицу фигур, которые описывает. Если фигура полностью вписывается в рамку четверти квадранта,
Фигура индексируется уже четвертью. И только если фигура не вписывается в рамки четвертей, она индексируется самим квадрантом.

Квадранты и фигуры контролируются своими провайдерами. У провайдеров в этом прототипе нет цели гарантировать эффективное использование памяти.
Здесь провайдеры выполняют роль статистов. Но поведение любого провайдера может быть изменено на более эффективное.
Прототип только показывает работу алгоритма и дает возможности оптимизации для достижения конкретных результатов.


#### Как этот код вообще работает

В основе этого кода лежит класс `Demo::QuadTree`, который и реализует интерфейс дерева квадратов.
Вложенный публичный тип `Demo::QuadTree::Shape` определяет интерфейс фигуры, а `Demo::QuadTree::SharedShape` можно использовать для определения переменных,
которые должны владеть арендуемой фигурой.

Каждая фигура описывается своей рамкой типа `Demo::BoundingRect`. Этот тип реализует семантику AABR, т.е. Axis-Aligned Bounding Rect - семантику рамки, 
ориентированной по осям координат. Рамка всегда однозначно определяет позицию фигуры в пространстве.


Аренда фигуры производится через вызов `Demo::QuadTree::Acquire`. Функция вернет `Demo::QuadTree::SharedShape` на новую уникальную фигуру и пока фигура
арендуется, дерево будет продолжать ее индексировать. Окончание аренды фигуры происходит тогда, когда все `Demo::QuadTree::SharedShape` перестанут ссылаться 
на фигуру.
Набор арендованных фигур всегда определяет область индексирования. Если арендуемая фигура выходит за границы уже построенного дерева, то все дерево сбрасывается и
область индексирования перестраивается.

В любой момент времени арендованную фигуру можно переместить с помощью вызова `Demo::QuadTree::Shape::SetBounds`. После вызова для фигуры будет задана новая 
рамка и фигура будет переиндексирована. А если новая рамка выходит за границы области индексирования, то все дерево будет сброшено и границы индексирования будут
пересчитаны.


Класс `Demo::Spatial::Internal::IndexTree` реализует дерево индексов. Функциональностью этого класса пользуется дерево квадратов.
Сам `IndexTree` управляет только консистентностью дерева, но не консистентностью данных в нем. Сбрасывать, перестраивать и определять границы индексирования
должен пользовательский класс - т.е. `QuadTree`.
Внутри `IndexTree` все фигуры сохраняются в промежуточной таблице. Это позволяет быстро перестраивать индекс по требованию.

В момент запроса поиска происходит постройка дерева индексов. При этом индексируются все известные дереву фигуры.
Если после постройки дерева происходит аренда новой фигуры внутри области индексирования, то дерево не сбрасывается, а точки фигуры сразу индексируются.
Если после постройки дерева завершается аренда фигуры, то ее точки безопасно удаляются из дерева и дерево не сбрасывается.


#### Сборка и проверка

Сборка этого кода проводилась в MS Visual Studio 2019. Попутно этот код проверялся на Clang 15 и GCC 12.2.
Проблем в сборке или работе выявлено не было. Этот код написан в стандарте C++17 и по праву может считаться кросс-платформенным.
Запуск этого кода проводился также в VS2019, а попутно и в Clang 15 с GCC 12.2.

Проект для VS19 находится в папке `./project`. Исходный код расположен в папке `./source`.


#### Используемая в работе информация

- https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D0%BD%D1%82%D0%BE%D0%B2
- https://habr.com/ru/post/473066/
- https://gamedev.ru/art/articles/?id=6999
- https://github.com/pvigier/Quadtree
- https://github.com/psimatis/QuadTree

#### Лицензия

Этот код лицензируется по правилам MIT лицензии. Подробности есть в файле лицензии.

Основной репозиторий этого кода: https://github.com/FrankStain/QuadTreeSample
